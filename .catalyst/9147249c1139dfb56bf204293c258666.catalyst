{"title":{"en":"A. Array Elimination","ru":"A. Уничтожение массива"},"contestId":"1601","problemIndex":"A","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"512 megabytes","ru":"512 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p>You are given array $$$a_1, a_2, \\ldots, a_n$$$, consisting of non-negative integers.</p><p>Let's define operation of \"elimination\" with integer parameter $$$k$$$ ($$$1 \\leq k \\leq n$$$) as follows:</p><ul> <li> Choose $$$k$$$ distinct array indices $$$1 \\leq i_1 &lt; i_2 &lt; \\ldots &lt; i_k \\le n$$$. </li><li> Calculate $$$x = a_{i_1} ~ \\&amp; ~ a_{i_2} ~ \\&amp; ~ \\ldots ~ \\&amp; ~ a_{i_k}$$$, where $$$\\&amp;$$$ denotes the <a href=\"https://en.wikipedia.org/wiki/Bitwise_operation#AND\">bitwise AND operation</a> (notes section contains formal definition). </li><li> Subtract $$$x$$$ from each of $$$a_{i_1}, a_{i_2}, \\ldots, a_{i_k}$$$; all other elements remain untouched. </li></ul><p>Find all possible values of $$$k$$$, such that it's possible to make all elements of array $$$a$$$ equal to $$$0$$$ using a finite number of elimination operations with parameter $$$k$$$. It can be proven that exists at least one possible $$$k$$$ for any array $$$a$$$.</p><p>Note that you <span class=\"tex-font-style-bf\">firstly choose $$$k$$$ and only after that perform elimination operations with value $$$k$$$ you've chosen initially</span>.</p>","ru":"<p>Вам задан массив $$$a_1, a_2, \\ldots, a_n$$$, состоящий из неотрицательных целых чисел.</p><p>Определим операцию «уничтожения» с целочисленным параметром $$$k$$$ ($$$1 \\leq k \\leq n$$$) следующим образом:</p><ul> <li> Выбираем $$$k$$$ различных индексов массива $$$1 \\leq i_1 &lt; i_2 &lt; \\ldots &lt; i_k \\le n$$$. </li><li> Вычисляем $$$x = a_{i_1} ~ \\&amp; ~ a_{i_2} ~ \\&amp; ~ \\ldots ~ \\&amp; ~ a_{i_k}$$$, где $$$\\&amp;$$$ обозначает операцию <a href=\"https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_И\">побитового И</a> (обратитесь к тексту в примечании для формального определения). </li><li> Вычитаем $$$x$$$ из всех $$$a_{i_1}, a_{i_2}, \\ldots, a_{i_k}$$$; остальные элементы массива оставляем без изменения. </li></ul><p>Найдите все значения $$$k$$$, для которых с помощью конечного количества операций уничтожения с параметром $$$k$$$ можно сделать все элементы массива $$$a$$$ равными $$$0$$$. Можно показать, что для любого массива $$$a$$$ существует хотя бы одно подходящее $$$k$$$.</p><p>Обратите внимание, что вы <span class=\"tex-font-style-bf\">сначала выбираете значение $$$k$$$ и только потом применяете операции уничтожения с первоначально выбранным параметром $$$k$$$</span>.</p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$). Description of the test cases follows.</p><p>The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)&nbsp;— the length of array $$$a$$$.</p><p>The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i &lt; 2^{30}$$$)&nbsp;— array $$$a$$$ itself.</p><p>It's guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$200\\,000$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>Во входных данных находятся несколько наборов входных данных. В первой строке находится одно целое число $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$)&nbsp;— количество наборов входных данных. Далее следуют сами наборы входных данных.</p><p>В первой строке каждого набора задано одно целое число $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)&nbsp;— длина массива $$$a$$$.</p><p>В следующей строке каждого набора задано $$$n$$$ целых чисел $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i &lt; 2^{30}$$$)&nbsp;— массив $$$a$$$.</p><p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных не превосходит $$$200\\,000$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>For each test case, print all values $$$k$$$, such that it's possible to make all elements of $$$a$$$ equal to $$$0$$$ in a finite number of elimination operations with the given parameter $$$k$$$.</p><p><span class=\"tex-font-style-bf\">Print them in increasing order.</span></p>","ru":"<div class=\"section-title\">Выходные данные</div><p>Для каждого набора входных данных выведите все значения $$$k$$$, для которых с помощью операций уничтожения (с заданным параметром $$$k$$$) можно сделать все элементы массива $$$a$$$ равными $$$0$$$.</p><p><span class=\"tex-font-style-bf\">Выводите их в возрастающем порядке.</span></p>"},"noteHtml":{"en":"<div class=\"section-title\">Note</div><p>In the first test case:</p><ul> <li> If $$$k = 1$$$, we can make four elimination operations with sets of indices $$$\\{1\\}$$$, $$$\\{2\\}$$$, $$$\\{3\\}$$$, $$$\\{4\\}$$$. Since $$$\\&amp;$$$ of one element is equal to the element itself, then for each operation $$$x = a_i$$$, so $$$a_i - x = a_i - a_i = 0$$$. </li><li> If $$$k = 2$$$, we can make two elimination operations with, for example, sets of indices $$$\\{1, 3\\}$$$ and $$$\\{2, 4\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_3$$$ $$$=$$$ $$$a_2 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$4 ~ \\&amp; ~ 4 = 4$$$. For both operations $$$x = 4$$$, so after the first operation $$$a_1 - x = 0$$$ and $$$a_3 - x = 0$$$, and after the second operation&nbsp;— $$$a_2 - x = 0$$$ and $$$a_4 - x = 0$$$. </li><li> If $$$k = 3$$$, it's impossible to make all $$$a_i$$$ equal to $$$0$$$. After performing the first operation, we'll get three elements equal to $$$0$$$ and one equal to $$$4$$$. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to $$$0$$$. </li><li> If $$$k = 4$$$, we can make one operation with set $$$\\{1, 2, 3, 4\\}$$$, because $$$x = a_1 ~ \\&amp; ~ a_2 ~ \\&amp; ~ a_3 ~ \\&amp; ~ a_4$$$ $$$= 4$$$. </li></ul><p>In the second test case, if $$$k = 2$$$ then we can make the following elimination operations:</p><ul> <li> Operation with indices $$$\\{1, 3\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_3$$$ $$$=$$$ $$$13 ~ \\&amp; ~ 25 = 9$$$. $$$a_1 - x = 13 - 9 = 4$$$ and $$$a_3 - x = 25 - 9 = 16$$$. Array $$$a$$$ will become equal to $$$[4, 7, 16, 19]$$$. </li><li> Operation with indices $$$\\{3, 4\\}$$$: $$$x = a_3 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$16 ~ \\&amp; ~ 19 = 16$$$. $$$a_3 - x = 16 - 16 = 0$$$ and $$$a_4 - x = 19 - 16 = 3$$$. Array $$$a$$$ will become equal to $$$[4, 7, 0, 3]$$$. </li><li> Operation with indices $$$\\{2, 4\\}$$$: $$$x = a_2 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$7 ~ \\&amp; ~ 3 = 3$$$. $$$a_2 - x = 7 - 3 = 4$$$ and $$$a_4 - x = 3 - 3 = 0$$$. Array $$$a$$$ will become equal to $$$[4, 4, 0, 0]$$$. </li><li> Operation with indices $$$\\{1, 2\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_2$$$ $$$=$$$ $$$4 ~ \\&amp; ~ 4 = 4$$$. $$$a_1 - x = 4 - 4 = 0$$$ and $$$a_2 - x = 4 - 4 = 0$$$. Array $$$a$$$ will become equal to $$$[0, 0, 0, 0]$$$. </li></ul><p><span class=\"tex-font-style-bf\">Formal definition of bitwise AND:</span></p><p>Let's define bitwise AND ($$$\\&amp;$$$) as follows. Suppose we have two non-negative integers $$$x$$$ and $$$y$$$, let's look at their binary representations (possibly, with leading zeroes): $$$x_k \\dots x_2 x_1 x_0$$$ and $$$y_k \\dots y_2 y_1 y_0$$$. Here, $$$x_i$$$ is the $$$i$$$-th bit of number $$$x$$$, and $$$y_i$$$ is the $$$i$$$-th bit of number $$$y$$$. Let $$$r = x ~ \\&amp; ~ y$$$ is a result of operation $$$\\&amp;$$$ on number $$$x$$$ and $$$y$$$. Then binary representation of $$$r$$$ will be $$$r_k \\dots r_2 r_1 r_0$$$, where:</p><p>$$$$$$ r_i = \\begin{cases} 1, ~ \\text{if} ~ x_i = 1 ~ \\text{and} ~ y_i = 1 \\\\ 0, ~ \\text{if} ~ x_i = 0 ~ \\text{or} ~ y_i = 0 \\end{cases} $$$$$$</p>","ru":"<div class=\"section-title\">Примечание</div><p>В первом наборе входных данных:</p><ul> <li> При $$$k = 1$$$ мы можем сделать четыре операции уничтожения с наборами индексов $$$\\{1\\}$$$, $$$\\{2\\}$$$, $$$\\{3\\}$$$, $$$\\{4\\}$$$. Так как $$$\\&amp;$$$ одного элемента равен самому элементу, то при каждой операции $$$x = a_i$$$, и $$$a_i - x = a_i - a_i = 0$$$. </li><li> При $$$k = 2$$$ мы можем сделать две операции уничтожения с наборами индексов, например, $$$\\{1, 3\\}$$$ и $$$\\{2, 4\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_3$$$ $$$=$$$ $$$a_2 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$4 ~ \\&amp; ~ 4 = 4$$$. При каждой из этих операций $$$x = 4$$$, а потому после первой операции $$$a_1 - x = 0$$$ и $$$a_3 - x = 0$$$, и после второй&nbsp;— $$$a_2 - x = 0$$$ и $$$a_4 - x = 0$$$. </li><li> При $$$k = 3$$$ невозможно сделать все $$$a_i$$$ равными $$$0$$$. Если мы сделаем любую операцию уничтожения в самом начале, то в нашем массиве три числа станут равными $$$0$$$ и одно число останется равным $$$4$$$. После этого любая операция уничтожения не будет изменять массив, потому что среди выбранных индексов будет хотя бы один, значение массива для которого уже равно $$$0$$$. </li><li> При $$$k = 4$$$ мы можем сделать одну операцию уничтожения с набором индексов $$$\\{1, 2, 3, 4\\}$$$, потому что $$$x = a_1 ~ \\&amp; ~ a_2 ~ \\&amp; ~ a_3 ~ \\&amp; ~ a_4$$$ $$$= 4$$$. </li></ul><p>Во втором наборе входных данных при $$$k = 2$$$ мы можем сделать следующие операции уничтожения:</p><ul> <li> Операция с индексами $$$\\{1, 3\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_3$$$ $$$=$$$ $$$13 ~ \\&amp; ~ 25 = 9$$$. $$$a_1 - x = 13 - 9 = 4$$$ и $$$a_3 - x = 25 - 9 = 16$$$. Массив $$$a$$$ после операции станет $$$[4, 7, 16, 19]$$$. </li><li> Операция с индексами $$$\\{3, 4\\}$$$: $$$x = a_3 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$16 ~ \\&amp; ~ 19 = 16$$$. $$$a_3 - x = 16 - 16 = 0$$$ и $$$a_4 - x = 19 - 16 = 3$$$. Массив $$$a$$$ после операции станет $$$[4, 7, 0, 3]$$$. </li><li> Операция с индексами $$$\\{2, 4\\}$$$: $$$x = a_2 ~ \\&amp; ~ a_4$$$ $$$=$$$ $$$7 ~ \\&amp; ~ 3 = 3$$$. $$$a_2 - x = 7 - 3 = 4$$$ и $$$a_4 - x = 3 - 3 = 0$$$. Массив $$$a$$$ после операции станет $$$[4, 4, 0, 0]$$$. </li><li> Операция с индексами $$$\\{1, 2\\}$$$: $$$x = a_1 ~ \\&amp; ~ a_2$$$ $$$=$$$ $$$4 ~ \\&amp; ~ 4 = 4$$$. $$$a_1 - x = 4 - 4 = 0$$$ и $$$a_2 - x = 4 - 4 = 0$$$. Массив $$$a$$$ после операции станет $$$[0, 0, 0, 0]$$$. </li></ul><p><span class=\"tex-font-style-bf\">Формальное определение побитового «И»</span></p><p>Определим операцию побитового «И» ($$$\\&amp;$$$). Пусть даны два целых неотрицательных числа $$$x$$$ и $$$y$$$, рассмотрим их двоичные записи (возможно с ведущими нулями): $$$x_k \\dots x_2 x_1 x_0$$$ и $$$y_k \\dots y_2 y_1 y_0$$$. Здесь $$$x_i$$$ это $$$i$$$-й бит числа $$$x$$$, а $$$y_i$$$ это $$$i$$$-й бит числа $$$y$$$. Пусть $$$r = x ~ \\&amp; ~ y$$$&nbsp;— результат операции $$$\\&amp;$$$ над числами $$$x$$$ и $$$y$$$. Тогда двоичной записью $$$r$$$ будет $$$r_k \\dots r_2 r_1 r_0$$$, где:</p><p>$$$$$$ r_i = \\begin{cases} 1, ~ \\text{if} ~ x_i = 1 ~ \\text{and} ~ y_i = 1 \\\\ 0, ~ \\text{if} ~ x_i = 0 ~ \\text{or} ~ y_i = 0 \\end{cases} $$$$$$</p>"},"sampleTestcases":[{"id":1636829073686,"input":"5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n","output":"1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"}],"submitUrl":"https://codeforces.com/contest/1601/submit","language":"c++"}